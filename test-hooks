#!/usr/bin/python
'''Test the various package hooks.'''

import unittest, subprocess, tempfile, os, shutil, os.path, sys, optparse
from cStringIO import StringIO
import apport, apport.fileutils

# parse command line options
optparser = optparse.OptionParser('%prog [options]')
optparser.add_option('-l', '--local',
    help='Test scripts in ./bin/ instead of /usr/share/apport/',
    action='store_true', dest='local', default=False)
options, args = optparser.parse_args()

if options.local:
    basedir = 'bin'
else:
    basedir = '/usr/share/apport'

class _HooksTest(unittest.TestCase):
    def setUp(self):
        self.orig_report_dir = apport.fileutils.report_dir
        apport.fileutils.report_dir = tempfile.mkdtemp()
        os.environ['APPORT_REPORT_DIR'] = apport.fileutils.report_dir

        self.workdir = tempfile.mkdtemp()

    def tearDown(self):
        shutil.rmtree(apport.fileutils.report_dir)
        apport.fileutils.report_dir = self.orig_report_dir 

        shutil.rmtree(self.workdir)

    def test_package_hook_nologs(self):
        '''Test package_hook without any log files.'''

        ph = subprocess.Popen(['%s/package_hook' % basedir, '-p', 'bash'],
            stdin=subprocess.PIPE)
        ph.communicate('something is wrong')
        self.assertEqual(ph.returncode, 0, 'package_hook finished successfully')

        reps = apport.fileutils.get_new_reports()
        self.assertEqual(len(reps), 1, 'package_hook created a report')

        r = apport.Report()
        r.load(open(reps[0]))

        self.assertEqual(r['ProblemType'], 'Package')
        self.assertEqual(r['Package'], 'bash')
        self.assertEqual(r['SourcePackage'], 'bash')
        self.assertEqual(r['ErrorMessage'], 'something is wrong')

    def test_package_hook_uninstalled(self):
        '''Test package_hook on an uninstalled package (might fail to install).'''

        #FIXME: This is a really Debian/Ubuntu specific dodgy test case
        ph = subprocess.Popen(['%s/package_hook' % basedir, '-p', 'libdb4.3-tcl'],
            stdin=subprocess.PIPE)
        ph.communicate('something is wrong')
        self.assertEqual(ph.returncode, 0, 'package_hook finished successfully')

        reps = apport.fileutils.get_new_reports()
        self.assertEqual(len(reps), 1, 'package_hook created a report')

        r = apport.Report()
        r.load(open(reps[0]))

        self.assertEqual(r['ProblemType'], 'Package')
        self.assertEqual(r['Package'], 'libdb4.3-tcl')
        self.assertEqual(r['SourcePackage'], 'db4.3')
        self.assertEqual(r['ErrorMessage'], 'something is wrong')

    def test_package_hook_logs(self):
        '''Test package_hook with a log dir and a log file.'''

        open(os.path.join(self.workdir, 'log_1.log'), 'w').write('Log 1\nbla')
        open(os.path.join(self.workdir, 'log2'), 'w').write('Yet\nanother\nlog')

        ph = subprocess.Popen(['%s/package_hook' % basedir, '-p', 'bash', '-l',
            os.path.realpath(sys.argv[0]), '-l', self.workdir],
            stdin=subprocess.PIPE)
        ph.communicate('something is wrong')
        self.assertEqual(ph.returncode, 0, 'package_hook finished successfully')

        reps = apport.fileutils.get_new_reports()
        self.assertEqual(len(reps), 1, 'package_hook created a report')

        r = apport.Report()
        r.load(open(reps[0]))

        filekey = None
        log1key = None
        log2key = None
        for k in r.keys():
            if k.endswith('Testhooks'):
                filekey = k
            elif k.endswith('Log1log'):
                log1key = k
            elif k.endswith('Log2'):
                log2key = k

        self.assert_(filekey)
        self.assert_(log1key)
        self.assert_(log2key)
        self.assert_('0234lkjas' in r[filekey])
        self.assertEqual(len(r[filekey]), os.path.getsize(sys.argv[0]))
        self.assertEqual(r[log1key], 'Log 1\nbla')
        self.assertEqual(r[log2key], 'Yet\nanother\nlog')

    def test_kernel_hook(self):
        '''Test kernel_hook.'''

        self.assertEqual(subprocess.call('%s/kernel_hook' % basedir), 0,
            'kernel_hook finished successfully')

        reps = apport.fileutils.get_new_reports()
        self.assertEqual(len(reps), 1, 'kernel_hook created a report')

        r = apport.Report()
        r.load(open(reps[0]))

        self.assertEqual(set(r.keys()), set(['Date', 'Dmesg', 'ProcModules',
            'LsPciVV', 'LsPciVVN', 'Package', 'ProblemType', 'ProcCpuInfo',
            'ProcVersion', 'ProcVersionSignature', 'ProcCmdline', 'SourcePackage']))

        self.assertEqual(r['ProblemType'], 'Kernel')

        self.assert_(os.uname()[2].split('-')[0] in r['SourcePackage'])
        self.assertEqual(r['ProcVersion'],
            open('/proc/version').read().strip())

    @classmethod
    def _gcc_version_path(klass):
        '''Determine a valid version and executable path of gcc and return it
        as a tuple.'''

        gcc = subprocess.Popen(['gcc', '--version'], stdout=subprocess.PIPE)
        out = gcc.communicate()[0]
        assert gcc.returncode == 0, '"gcc --version" must work for this test suite'

        gcc_ver = '.'.join(out.splitlines()[0].split()[2].split('.')[:2])
        gcc_path = '/usr/bin/gcc-' + gcc_ver

        assert subprocess.call([gcc_path, '--version'], stdout=subprocess.PIPE) == 0, \
            gcc_path + ' must exist and work for this test suite'

        return (gcc_ver, gcc_path)
 
    def test_gcc_ide_hook_file(self):
        '''Test gcc_ice_hook with a temporary file.'''

        (gcc_version, gcc_path) = self._gcc_version_path()

        test_source = tempfile.NamedTemporaryFile()
        test_source.write('int f(int x);')
        test_source.flush()
        test_source.seek(0)

        self.assertEqual(subprocess.call(['%s/gcc_ice_hook' % basedir,
            gcc_path, test_source.name]), 0, 'gcc_ice_hook finished successfully')

        reps = apport.fileutils.get_new_reports()
        self.assertEqual(len(reps), 1, 'gcc_ice_hook created a report')

        r = apport.Report()
        r.load(open(reps[0]))

        self.assertEqual(r['ProblemType'], 'Crash')
        self.assertEqual(r['ExecutablePath'], gcc_path)
        self.assertEqual(r['PreprocessedSource'], test_source.read())

        r.add_package_info()

        self.assert_(r['Package'].startswith('gcc-' + gcc_version))
        self.assert_(r['SourcePackage'].startswith('gcc'))

    def test_gcc_ide_hook_pipe(self):
        '''Test gcc_ice_hook with piping.'''

        (gcc_version, gcc_path) = self._gcc_version_path()

        test_source = 'int f(int x);'

        hook = subprocess.Popen(['%s/gcc_ice_hook' % basedir, gcc_path, '-'], 
            stdin=subprocess.PIPE)
        hook.communicate(test_source)
        self.assertEqual(hook.returncode, 0, 'gcc_ice_hook finished successfully')

        reps = apport.fileutils.get_new_reports()
        self.assertEqual(len(reps), 1, 'gcc_ice_hook created a report')

        r = apport.Report()
        r.load(open(reps[0]))

        self.assertEqual(r['ProblemType'], 'Crash')
        self.assertEqual(r['ExecutablePath'], gcc_path)
        self.assertEqual(r['PreprocessedSource'], test_source)

        r.add_package_info()

        self.assert_(r['Package'].startswith('gcc-' + gcc_version))
        self.assert_(r['SourcePackage'].startswith('gcc'))

# call tests

tl = unittest.TestLoader()
tests_all = unittest.TestSuite((
    tl.loadTestsFromName('__main__')
))
unittest.TextTestRunner(verbosity=2).run(tests_all)
