#!/usr/bin/python

# Collect information about a crash and create a report in the directory
# specified by apport_utils.report_dir.
# See https://wiki.ubuntu.com/AutomatedProblemReports for details.
#
# Copyright (c) 2006 Canonical Ltd.
# Author: Martin Pitt <martin.pitt@ubuntu.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See http://www.gnu.org/copyleft/gpl.html for
# the full text of the license.

import sys, os, os.path, subprocess, time, traceback, tempfile, glob

import problem_report

sys.path.append(os.path.abspath(os.path.dirname(sys.argv[0])))
import apport_utils

#################################################################
#
# functions
#
#################################################################

def _command_output(command, input = None, stderr = subprocess.STDOUT):
    '''Try to execute given command (array) and return its stdout, or return
    a textual error if it failed.'''

    try:
	sp = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=stderr, close_fds=True)
    except OSError, e:
	error_log('_command_output Popen(%s): %s' % (str(command), str(e)))
	return 'Error: ' + str(e)

    out = sp.communicate(input)[0]
    if sp.returncode == 0:
	return out
    else:
	error_log('_command_output %s failed with exit code %i: %s' % (
	    str(command), sp.returncode, out))
	return 'Error: command %s failed with exit code %i: %s' % (
	    str(command), sp.returncode, out)

def drop_privileges(pid):
    '''Change user and group to match the given target process.'''

    stat = None
    try:
	stat = os.stat('/proc/' + pid)
    except OSError:
	raise ValueError, 'Invalid process ID'

    os.setgid(stat.st_gid)
    os.setuid(stat.st_uid)
    assert os.getuid() == stat.st_uid

def init_error_log():
    '''Open a suitable error log if sys.stderr is not a tty.'''

    if not os.isatty(sys.stderr.fileno()):
	try:
	    f = open('/var/log/apport.log', 'a')
	except IOError: # on a permission error, don't touch stderr
	    return
	os.dup2(f.fileno(), sys.stderr.fileno())
	os.dup2(f.fileno(), sys.stdout.fileno())
	f.close()

def error_log(msg):
    '''Output something to the error log.'''

    print >> sys.stderr, 'apport (pid %s) %s:' % (os.getpid(),
	time.asctime()), msg

#################################################################
#
# classes
#
#################################################################

class InformationCollector:
    '''Collect and store information about the crash.
    
    Fields with acquired data:
    - Signal: signal that caused the crash
    - ExecutablePath: path to the crashed executable
    - Stacktrace: stack trace
    - ThreadStacktrace: thread apply all bt full
    - Package: package name and version; not present if info['ExecutablePath'] does
      not belong to a package
    - SourcePackage: source package name
    - Dependencies: names and versions of depending packages; not present if
      Package is not present
    - ProcCmdline: /proc/<pid>/cmdline
    - ProcEnviron: /proc/<pid>/environ
    - ProcStatus: /proc/<pid>/status
    - ProcMaps: /proc/<pid>/maps
    - DistroRelease: lsb_release -sir
    - Uname: uname -a

    TODO: StackFrame
    '''

    def __init__(self, pid, signum, coredump = None, pkg = None):
	'''Initialize object, but do not collect information yet.'''

	self.info = problem_report.ProblemReport('Crash')
	self.info['Signal'] = signum
	self.pid = pid
	self.pkg = pkg
	if coredump:
	    self.info['CoreDump'] = (coredump,)
	self.unlink_coredump = False

	# determine program name
	self.info['ExecutablePath'] = os.readlink('/proc/' + pid + '/exe')

    def collect_runtime_information(self):
	'''Collect information about the process runtime (mainly from /proc).

	This requires that the target process still exists and needs root
	privileges.'''

	apport_utils.report_add_proc_info(self.info, self.pid)

    def collect_static_information(self):
	'''Collect information about the process' environment and other static
	data.

	The process does not need to exist any more, and no special privileges
	are required.'''

	# get package, if we do not yet have it
	if not self.pkg:
	    self.pkg = apport_utils.find_file_package(self.info['ExecutablePath'])
	if not self.pkg:
	    return 
	apport_utils.report_add_package_info(self.info, self.pkg)
	apport_utils.report_add_os_info(self.info)
	self._get_gdb()

    def __del__(self):
	if self.unlink_coredump:
	    os.unlink(self.info['CoreDump'][0])

    def _get_gdb(self):
	'''Get information from gdb.
	
	This only works if we have a core dump. We cannot generate a core dump
	on our own if we are called by the kernel, since the target process is
	in uninterruptible kernel sleep.'''

	if not self.info.has_key('CoreDump'):
	    return
	core = self.info['CoreDump'][0]

	self.info['Stacktrace'] = _command_output(['gdb', '--batch', '--ex',
	    'bt full', self.info['ExecutablePath'], core],
	    stderr=open('/dev/null')).replace('\n\n', '\n.\n').strip()
	self.info['ThreadStacktrace'] = _command_output(['gdb', '--batch', '--ex',
	    'thread apply all bt full', self.info['ExecutablePath'], core],
	    stderr=open('/dev/null')).replace('\n\n', '\n.\n').strip()

	self._copy_shrink_corefile()

    def _copy_shrink_corefile(self):
	'''Copy the core file and redue its size.
	
	The original core dump will be removed by the kernel once the
	kernel-invoked apport instance exits.'''

	if not self.info.has_key('CoreDump'):
	    return

	shrinkcorefile = tempfile.NamedTemporaryFile()
	shrinkcorefile.close()
	if subprocess.call(['objcopy', self.info['CoreDump'][0], shrinkcorefile.name],
	    stderr=subprocess.PIPE) == 0 \
	    and os.path.exists(shrinkcorefile.name):
	    self.info['CoreDump'] = (shrinkcorefile.name,)
	    self.unlink_coredump = True

#################################################################
#
# main
#
#################################################################

init_error_log()

if len(sys.argv) < 3 or len(sys.argv) > 4:
    print >> sys.stderr, 'Usage:', sys.argv[0], '<pid> <signal number> [<path to core dump>]'
    sys.exit(1)


pid = sys.argv[1]
signum = sys.argv[2]

# try to find the core dump file
if len(sys.argv) == 4:
    coredump = sys.argv[3]
else:
    coredump = None

# if path is relative, prepend cwd of crashed process
if coredump and len(coredump) > 0 and coredump[0] != '/':
    coredump = os.path.join(os.readlink('/proc/' + pid + '/cwd'), coredump)

if coredump and not os.path.exists(coredump):
    coredump = None

error_log('called with: ' + str(sys.argv) + ', using core file ' + str(coredump))

try:
    pidstat = os.stat('/proc/' + pid)
except OSError:
    error_log('Invalid PID')
    sys.exit(1)

exename = os.readlink('/proc/' + pid + '/exe')

# ignore non-package binaries
pkg = None
if exename.startswith('/home') or exename.startswith('/tmp'):
    pkg = None
else:
    pkg = apport_utils.find_file_package(exename)
if not pkg:
    error_log('executable does not belong to a package, ignoring')
    sys.exit(1)

crash_counter = 0

# Create crash report file descriptor. We prefer to create the report in
# report_dir if we can create a file there; if not, we just use stderr.
try:
    report = '%s/%s.%i.crash' % (apport_utils.report_dir, exename.replace('/', '_'), pidstat.st_uid)
    if os.path.exists(report):
	if apport_utils.seen_report(report):
	    # do not flood the logs and the user with repeated crashes
	    crash_counter = apport_utils.get_recent_crashes(open(report))
	    crash_counter += 1
	    if crash_counter > 4:
		sys.exit(1)
	else:
	    error_log('apport: report %s already exists and unseen, doing nothing to avoid disk usage DoS' % report)
	    sys.exit(1)
    reportfile = open(report, 'w')
    os.chmod(report, 0600)
    os.chown(report, pidstat.st_uid, pidstat.st_gid)
except (OSError, IOError):
    reportfile = sys.stderr

try:
    ic = InformationCollector(pid, signum, coredump, pkg=pkg)

    # reading /proc after drop_privileges() (when called from the kernel)
    # does not work, so do this with original privileges.
    ic.collect_runtime_information()
    drop_privileges(pid)
    ic.collect_static_information()

    if crash_counter > 0:
	ic.info['CrashCounter'] = '%i' % crash_counter

    ic.info.write(reportfile)
    if reportfile != sys.stderr:
	error_log('wrote report %s for package %s' % (report, ic.info['Package']))
except SystemExit:
    raise
except Exception, e:
    error_log('Unhandled exception:')
    traceback.print_exc()
    print >> sys.stderr, 'pid: %i, uid: %i, gid: %i, euid: %i, egid: %i' % (
       os.getpid(), os.getuid(), os.getgid(), os.geteuid(), os.getegid())
