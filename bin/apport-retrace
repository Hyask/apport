#!/usr/bin/python

# Use the coredump in a crash report to regenerate the stack traces. This is
# helpful to get a trace with debug symbols.
#
# Copyright (c) 2006 Canonical Ltd.
# Author: Martin Pitt <martin.pitt@ubuntu.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See http://www.gnu.org/copyleft/gpl.html for
# the full text of the license.

import sys, os, os.path, subprocess, optparse, shutil, tempfile, glob, gzip, re
import tty, termios
import apport, apport.fileutils

import warnings
warnings.filterwarnings("ignore", "apt API not stable yet", FutureWarning)
import apt

from launchpadBugs.HTMLOperations import Bug

#
# functions
#

def parse_options():
    '''Parse command line options and return (reportfile, options) tuple.'''

    optparser = optparse.OptionParser('%prog [options] <apport problem report | Launchpad bug number>')
    optparser.add_option('-c', '--remove-core', 
        help='Remove the core dump from the report after stack trace regeneration',
        action='store_true', dest='removecore', default=False)
    optparser.add_option('-s', '--stdout', 
        help='Do not put the new traces into the report, but write them to stdout.',
        action='store_true', dest='stdout', default=False)
    optparser.add_option('-g', '--gdb', 
        help="Start an interactive gdb session with the report's core dump (-o ignored; does not rewrite report)",
        action='store_true', dest='gdb', default=False)
    optparser.add_option('-r', '--core-file', 
        help="Override report's CoreFile",
        action='store', type='string', dest='core_file', metavar='CORE', default=None)
    optparser.add_option('-x', '--executable', 
        help="Override report's ExecutablePath",
        action='store', type='string', dest='executable', metavar='EXE', default=None)
    optparser.add_option('-m', '--procmaps', 
        help="Override report's ProcMaps",
        action='store', type='string', dest='procmaps', metavar='MAPS', default=None)
    optparser.add_option('-v', '--verbose', 
        help='Report download/install progress when installing additional packages',
        action='count', dest='verbose', default=0)
    optparser.add_option('-o', '--output', 
        help='Write modified report to given file instead of changing the original report',
        action='store', type='string', dest='output', metavar='FILE', default=None)
    optparser.add_option('-u', '--unpack-only', 
        help='Only unpack the additionally required packages, do not configure them; purge packages again after retracing',
        action='store_true', dest='unpack_only', default=False)
    optparser.add_option('--no-purge', 
        help='Do not purge packages when using -u. This should only be used for temporarily unpacked chroot tarballs where it would just be a waste of time.',
        action='store_true', dest='no_purge', default=False)
    optparser.add_option('-p', '--extra-package', 
        help='Install an extra package (can be specified multiple times)',
        action='append', type='string', dest='extra_packages', default=[])
    optparser.add_option('--cookie',
        help='Path to a Mozilla-style cookie file; this is used when specifying a Launchpad bug number to attach the retraced stack traces (only if neither -g, -o, nor -s are specified)',
        action='store', type='string', dest='cookie_file', default=None)
    optparser.add_option('--confirm',
        help='Display retraced stack traces and ask for confirmation before adding them as Launchpad bug attachments.',
        action='store_true', dest='confirm', default=False)

    (opts, args) = optparser.parse_args()

    if len(args) != 1:
        optparser.error('incorrect number of arguments; use --help for a short online help')
        sys.exit(1)

    return (args[0], opts)

def report_from_launchpad(bugid):
    '''Construct an Apport report from a Launchpad bug.'''

    report = apport.Report()
    attachment_dir = tempfile.mkdtemp()
    try:
        b = Bug(bugid, None, attachment_dir, ['application/x-gzip'],
            'Dependencies.txt|CoreDump.gz|ProcMaps.txt')

        for att in b.attachments:
            if not att.filename:
                continue # ignored attachments

            key = os.path.splitext(os.path.basename(att.filename))[0]

            if att.filename.endswith('.txt'):
                report[key] = open(att.filename).read()
            elif att.filename.endswith('.gz'):
                report[key] = gzip.open(att.filename).read()
            else:
                raise Exception, 'Unknown attachment type: ' + att.filename

        # parse out other fields from summary
        for m in re.finditer('^([a-zA-Z]+): (.*)<', b.text, re.M):
            report[m.group(1)] = m.group(2)

        return report
    finally:
        shutil.rmtree(attachment_dir)

def attach_to_launchpad_bug(bugnumber, report, cookie_file, comment=''):
    '''Attach the retraced stack traces of report to the given Launchpad bug,
    using a Mozilla-style cookie file.'''

    bug = Bug(bugnumber, cookie_file=cookie_file)

    comment += '\n\nStacktraceTop:' + report['StacktraceTop']

    t = tempfile.TemporaryFile()
    t.write(report['Stacktrace'])
    t.flush()
    t.seek(0)
    bug.add_comment('Symbolic stack trace', comment, t, 
        'Stacktrace.txt (retraced)')
    t.close()

    t = tempfile.TemporaryFile()
    t.write(report['ThreadStacktrace'])
    t.flush()
    t.seek(0)
    bug.add_comment('Symbolic threaded stack trace', '', t, 
        'ThreadStacktrace.txt (retraced)')
    t.close()

def deb_without_preinst(deb):
    '''If given .deb file has a preinst script, generate a <name>_noscript.deb
    file without it and return that name; otherwise, return deb.
    
    If the modified deb already exists, its name is returned without recreating
    it.'''

    ndeb = '/var/cache/apt/archives/%s_noscript%s' % os.path.splitext(os.path.basename(deb))

    if os.path.exists(ndeb):
        return ndeb

    # get control.tar.gz    
    ar = subprocess.Popen(['ar', 'p', deb, 'control.tar.gz'], stdout=subprocess.PIPE)
    control_tar = ar.communicate()[0]
    assert ar.returncode == 0

    # check if package has a preinst
    tar = subprocess.Popen(['tar', 'tz', './preinst'], stdin=subprocess.PIPE,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    tar.communicate(control_tar)
    if tar.returncode != 0:
        return deb

    # unpack control.tar.gz and remove scripts
    d = tempfile.mkdtemp()
    d2 = tempfile.mkdtemp()
    try:
        tar = subprocess.Popen(['tar', '-C', d, '-xz'], stdin=subprocess.PIPE)
        tar.communicate(control_tar)
        assert tar.returncode == 0
        for s in ('preinst', 'postinst', 'prerm', 'postrm'):
            path = os.path.join(d, s)
            if os.path.exists(path):
                os.unlink(path)

        control_tar_new = os.path.join(d2, 'control.tar.gz')
        tar = subprocess.Popen(['tar', '-C', d, '-cz', '.'],
            stdin=subprocess.PIPE, stdout=open(control_tar_new, 'w'))
        assert tar.wait() == 0

        shutil.copy(deb, ndeb)
        r = subprocess.Popen(['ar', 'r', ndeb, control_tar_new])
        assert r.wait() == 0
    finally:
        shutil.rmtree(d)
        shutil.rmtree(d2)

    return ndeb

def fetch_unpack(cache, fetchProgress, verbosity=0):
    '''Fetch the packages marked to be installed in the given apt.Cache()
    object and unpack them.
    
    fetchProgress must be a valid apt.progress.FetchProgress object.'''

    # fetch
    fetcher = apt.apt_pkg.GetAcquire(fetchProgress)
    pm = apt.apt_pkg.GetPackageManager(cache._depcache)
    try:
        res = cache._fetchArchives(fetcher, pm)
    except IOError, e:
        print >> sys.stderr, 'ERROR: could not fetch all archives:', e

    # extract
    if verbosity:
        so = sys.stderr
    else:
        so = subprocess.PIPE
    res = subprocess.call(['dpkg', '--force-depends', '--force-overwrite', '--unpack'] + 
        [deb_without_preinst(i.DestFile) for i in fetcher.Items], stdout=so)
    if res != 0:
        raise IOError, 'dpkg failed to unpack archives'

    # remove other maintainer scripts
    for c in cache.getChanges():
        for script in ('postinst', 'prerm', 'postrm'):
            try:
                os.unlink('/var/lib/dpkg/info/%s.%s' % (c.name, script))
            except OSError:
                pass

def install_missing_packages(report, verbosity = 0, unpack_only=False, extra_packages = []):
    '''Install packages which are required to retrace the given report.
    
    If package installation fails (e. g. because the user does not have root
    privileges), the list of required packages is printed out instead.
    
    Return a list of installed packages.'''

    c = apt.Cache()

    installed = []

    # create map of dependency package versions as specified in report
    dependency_versions = {}
    for l in (report['Package'] + '\n' + report.get('Dependencies', '')).splitlines():
        if not l.strip():
            continue
        (pkg, version) = l.split()[:2]
        dependency_versions[pkg] = version
        assert c[pkg]._lookupRecord()
        if not 'Architecture: all' in c[pkg]._records.Record:
            dependency_versions[pkg+'-dbgsym'] = dependency_versions[pkg]

    for pkg, ver in dependency_versions.iteritems():
	if not c.has_key(pkg):
	    print >> sys.stderr, 'WARNING: package %s not available' % pkg
	    continue

	# ignore packages which are already installed in the right version
	if (ver and c[pkg].installedVersion == ver) or \
	   (not ver and c[pkg].installedVersion):
	   continue

	if ver and c[pkg].candidateVersion != ver:
	    print >> sys.stderr, 'WARNING: %s version %s required, but %s is available' % (
		pkg, c[pkg].candidateVersion, ver)

	c[pkg].markInstall(False)

    # extra packages
    for p in extra_packages:
        c[p].markInstall(False)

    if verbosity:
        fetchProgress = apt.progress.TextFetchProgress()
	installProgress = apt.progress.InstallProgress()
    else:
        fetchProgress = apt.progress.FetchProgress()
	installProgress = apt.progress.DumbInstallProgress()

    try:
	if c.getChanges():
	    os.environ['DEBIAN_FRONTEND'] = 'noninteractive'
            if unpack_only:
                fetch_unpack(c, fetchProgress, verbosity)
            else:
                c.commit(fetchProgress, installProgress)
	    # after commit(), the Cache object does not empty the pending
	    # changes, so we need to reinitialize it to avoid applying the same
	    # changes again below
            installed = [p.name for p in c.getChanges()]
	    c = apt.Cache()
    except IOError, e:
	pass # we will complain to the user later

    # check list of libraries that the crashed process referenced at
    # runtime and warn about those which are not available
    libs = set()
    if report.has_key('ProcMaps'):
        for l in report['ProcMaps'].splitlines():
            if not l.strip():
                continue
            cols = l.split()
            if 'x' in cols[1] and len(cols) == 6 and '.so' in cols[5]:
                lib = os.path.realpath(cols[5])
                libs.add(lib)

    # grab as much as we can
    for l in libs:
	if not os.path.exists(l):
	    print >> sys.stderr, 'WARNING: %s was loaded at runtime, but is not available' % l
	    continue

	ldbg = '/usr/lib/debug' + l
	if os.path.exists(ldbg):
	    continue

	pkg = apport.fileutils.find_file_package(l)
	if pkg:
	    if c.has_key(pkg+'-dbgsym'):
		c[pkg+'-dbgsym'].markInstall(False)
	    else:
		print >> sys.stderr, 'WARNING: %s-dbgsym is not available' % pkg
	else:
		print >> sys.stderr, 'WARNING: %s is needed, but cannot be mapped to a package' % l

    try:
	if c.getChanges():
	    os.environ['DEBIAN_FRONTEND'] = 'noninteractive'
            if unpack_only:
                fetch_unpack(c, fetchProgress, verbosity)
            else:
                c.commit(fetchProgress, installProgress)
        installed += [p.name for p in c.getChanges()]
    except IOError, e:
	print >> sys.stderr, 'WARNING: could not install missing packages:', e
        if os.geteuid() != 0:
            print >> sys.stderr, 'You either need to call this program as root or install these packages manually:'
	for p in c.getChanges():
	    print >> sys.stderr, '  %s %s' % (p.name, p.candidateVersion)

    return installed

def getch():
    '''Read a single character from stdin.'''

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch

def confirm_traces(report):
    '''Display the retraced stack traces and ask the user whether or not to
    upload tem as Launchpad bug attachments.
    
    Return True if the user agrees.'''

    print '--- stack trace ---'
    print report['Stacktrace']
    print '--- thread stack trace ---'
    print report['ThreadStacktrace']
    print '---'

    ch = None
    while ch not in ['y', 'n']:
        print 'OK to send these as bug attachments? [y/n]'
        ch = getch().lower()

    return ch == 'y'

#
# main
#

(reportfile, options) = parse_options()

# load the report
if os.path.exists(reportfile):
    try:
        report = apport.Report()
        report.load(open(reportfile))
    except IOError, e:
        print >> sys.stderr, 'Cannot open report file:', e
        sys.exit(1)
elif reportfile.isdigit():
    # Launchpad bug number
    report = report_from_launchpad(reportfile)
    lpbug = reportfile
    reportfile = None
else:
    print >> sys.stderr, 'ERROR: "%s" is neither an existing report file nor a \
Launchpad bug number' % reportfile
    sys.exit(1)

if options.core_file:
    report['CoreDump'] = file(options.core_file).read()
if options.executable:
    report['ExecutablePath'] = options.executable
if options.procmaps:
    report['ProcMaps'] = file(options.procmaps).read()

# sanity checks
required_fields = set(['CoreDump', 'ExecutablePath', 'Package'])
if not required_fields.issubset(set(report.keys())):
    print >> sys.stderr, 'report file does not contain required fields: ' + \
	' '.join(required_fields)
    sys.exit(1)

installed = install_missing_packages(report, options.verbose,
    options.unpack_only, options.extra_packages)

# interactive gdb session
if options.gdb:
    core = tempfile.NamedTemporaryFile()
    core.write(report['CoreDump'])
    core.flush()
    subprocess.call(['gdb',
        '--ex', 'file ' + report.get('InterpreterPath', report['ExecutablePath']),
        '--ex', 'core-file ' + core.name])
    core.close()
else:
    # regenerate gdb info
    report.add_gdb_info()

modified = False

if options.removecore:
    del report['CoreDump']
    modified = True

if options.stdout:
    print '--- stack trace ---'
    print report['Stacktrace']
    print '--- thread stack trace ---'
    print report['ThreadStacktrace']
else:
    if not options.gdb:
        modified = True

if modified:
    if not reportfile and not options.output:
        if not options.cookie_file:
            print >> sys.stderr, 'You need to specify --cookie for attaching retraced results back to a Launchpad bug.'
            sys.exit(1)
        if not options.confirm or confirm_traces(report):
            attach_to_launchpad_bug(lpbug, report, options.cookie_file)
            print 'New attachments uploaded to Launchpad bug ' + lpbug
    else:
        if options.output == None:
            out = open(reportfile, 'w')
        elif options.output == '-':
            out = sys.stdout
        else:
            out = open(options.output, 'w')

        report.write(out)

if options.unpack_only and installed and not options.no_purge:
    if options.verbose:
        so = sys.stderr
    else:
        so = subprocess.PIPE
    subprocess.call(['dpkg', '-P'] + installed, stdout=so)
