#!/usr/bin/python

# Create an environment for evaluating a crash: use fakeroot and fakechroot to
# unpack a tarball with a base distribution, apt-get install a package and its
# ddebs, and run a command.
#
# Copyright (c) 2007 Canonical Ltd.  
# Author: Martin Pitt <martin.pitt@ubuntu.com>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.  See http://www.gnu.org/copyleft/gpl.html for the full text of the
# license.

import tempfile, subprocess, optparse, shutil, os.path, os, sys, glob

import apport, apport.fileutils

#
# Functions
#

def parse_options():
    '''Parse command line options and return (options, args) tuple.'''

    optparser = optparse.OptionParser('%prog [options] <orig report> <new report>')
    optparser.add_option('-t', '--tarball', 
        help='tarball of base distribution',
        action='store', type='string', dest='tarball', metavar='FILE', default=None)
    optparser.add_option('--apt-sources', 
        help='Use this value for /etc/apt/sources',
        action='store', type='string', dest='apt_sources', metavar='TEXT',
        default=None)
    optparser.add_option('-C', '--cache-dir', 
        help='Directory to use for caching downloaded packages. If not given, a temporary directory is used.',
        action='store', type='string', dest='cache_dir', metavar='DIR', default=None)

    return optparser.parse_args()

def create_chroot(rootdir, tarball, apt_sources=None, cache_dir=None):
    '''Setup a chroot from given tarball, an optional apt sources value, and an
    optional external cache directory.'''

    print 'Unpacking', tarball, '...'
    assert subprocess.call(['fakeroot', 'tar', '-C', rootdir, '-xzf', opts.tarball]) == 0

    # copy resolv.conf from main system
    open(os.path.join(rootdir, 'etc', 'resolv.conf'), 'w').write(
        open('/etc/resolv.conf').read())

    # setup apt.sources
    if apt_sources:
        open(os.path.join(rootdir, 'etc', 'apt', 'sources.list'),
            'w').write(apt_sources)

    print 'Updating apt sources...'
    assert subprocess.call(['fakeroot', 'fakechroot', 'chroot', rootdir,
        'apt-get', 'update']) == 0

    # setup apt cache dir
    if cache_dir:
        chroot_cachedir = os.path.join(rootdir, 'var', 'cache', 'apt', 'archives')
        shutil.rmtree(chroot_cachedir)
        os.symlink(os.path.realpath(cache_dir), chroot_cachedir)
        part = os.path.join(chroot_cachedir, 'partial')
        if not os.path.isdir(part):
            os.mkdir(part)

    # ensure that gdb is installed
    if subprocess.call(['fakeroot', 'fakechroot', 'chroot', rootdir,
        'dpkg', '-s', 'gdb'], stdout=subprocess.PIPE, stderr=subprocess.PIPE) != 0:
        assert subprocess.call(['fakeroot', 'fakechroot', 'chroot', rootdir,
            'apt-get', 'install', '-y', 'gdb']) == 0

def install_packages(rootdir, report):
    '''Install all packages into given chroot that are necessary to retrace the
    given report.'''

    package = report['Package'].split()[0]

    # get available packages
    avail = set()
    c = subprocess.Popen(['fakeroot', 'fakechroot', 'chroot', rootdir,
        'apt-cache', 'dumpavail'], stdout=subprocess.PIPE)
    for l in c.stdout:
        if l.startswith('Package:'):
            avail.add(l.split()[1])
    assert c.wait() == 0

    # figure out all dependencies
    c = subprocess.Popen(['fakeroot', 'fakechroot', 'chroot', rootdir,
        'apt-cache', 'showpkg', '--recurse', package], stdout=subprocess.PIPE)
    out = c.communicate()[0]
    assert c.returncode == 0

    # search first line after 'Dependencies:'
    depline = None
    for l in out.splitlines():
        if depline:
            depline = l
            break
        if l.startswith('Dependencies:'):
            depline = 1

    packages = [package]
    for token in depline.split()[2:]:
        if '(' in token or ')' in token:
            continue
        token += '-dbgsym'
        if token in avail:
            packages.append(token)
        else:
            print 'WARNING: package', token, 'not available'

    subprocess.call(['fakeroot', 'fakechroot', 'chroot', rootdir,
        'apt-get', 'install', '-y', '--force-yes'] + packages)

#
# main
#

(opts, args) = parse_options()

if len(args) != 2:
    print >> sys.stderr, 'Invalid arguments. Use --help for more information.'
    sys.exit(1)

report = apport.Report()
report.load(open(args[0]))
assert report.has_key('CoreDump')

rootdir = tempfile.mkdtemp()
try:
    create_chroot(rootdir, opts.tarball, opts.apt_sources, opts.cache_dir)

    # setup work directory
    workdir = os.path.join(rootdir, 'workdir')
    os.mkdir(workdir)

    # write core dump into chroot
    open(os.path.join(workdir, 'core'), 'w').write(report['CoreDump'])

    #install_packages(rootdir, report)

    subprocess.call(['fakeroot', 'fakechroot', 'chroot', rootdir])

finally:
    # clean up
    print 'Cleaning up...'
    shutil.rmtree(rootdir)

