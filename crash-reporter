#!/usr/bin/python

# Collect information about a crash and create a report in /var/crash/.
# See https://wiki.ubuntu.com/AutomatedProblemReports for details.
#
# Copyright (c) 2006 Canonical Ltd.
# Author: Martin Pitt <martin.pitt@ubuntu.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See http://www.gnu.org/copyleft/pgl.html for
# the full text of the license.

import sys, os, os.path, subprocess, time, traceback


#################################################################
#
# functions
#
#################################################################

def _read_file(f):
    '''Try to read given file and return its contents, or return a textual
    error if it failed.'''

    try:
	return open(f).read().strip()
    except IOError, e:
	error_log('_read_file %s: %s' % (f, str(e)))
	return 'Error: ' + str(e)

def _command_output(command, input = None, stderr = subprocess.STDOUT):
    '''Try to execute given command (array) and return its stdout, or return
    a textual error if it failed.'''

    try:
	sp = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=stderr, close_fds=True)
    except OSError, e:
	error_log('_command_output Popen(%s): %s' % (str(command), str(e)))
	return 'Error: ' + str(e)

    out = sp.communicate(input)[0]
    if sp.returncode == 0:
	return out
    else:
	error_log('_command_output %s failed with exit code %i: %s' % (
	    str(command), sp.returncode, out))
	return 'Error: command %s failed with exit code %i: %s' % (
	    str(command), sp.returncode, out)

def write_debcontrol(file, fields):
    '''Write dictionary 'fields' into the given file-like object, using Debian
    control file format.'''

    for k, v in fields.iteritems():
	if v.find('\n') >= 0:
	    assert v.find('\n\n') < 0
	    print >> file, k + ':'
	    print >> file, '', v.replace('\n', '\n ')
	else:
	    print >> file, k + ':', v

def drop_privileges(pid):
    '''Change user and group to match the given target process.'''

    stat = None
    try:
	stat = os.stat('/proc/' + pid)
    except OSError:
	raise ValueError, 'Invalid process ID'

    os.setgid(stat.st_gid)
    os.setuid(stat.st_uid)
    assert os.getuid() == stat.st_uid

def init_error_log():
    '''Open a suitable error log if sys.stderr is not a tty.'''

    if not os.isatty(sys.stderr.fileno()):
	f = open('/var/log/crash-reporter.log', 'a')
	os.dup2(f.fileno(), sys.stderr.fileno())
	os.dup2(f.fileno(), sys.stdout.fileno())

def error_log(msg):
    '''Output something to the error log.'''

    print >> sys.stderr, 'crash-reporter (pid %s) %s:' % (os.getpid(),
	time.asctime()), msg

#################################################################
#
# classes
#
#################################################################

class InformationCollector:
    '''Collect and store information about the crash.
    
    Fields with acquired data:
    - signal: signal that caused the crash
    - executable: path to the crashed executable
    - stacktrace: stack trace
    - thread_stacktrace: thread apply all bt full
    - environment: env variables from /proc/<pid>/environ
    - pkg: package name and version; not present if info['executable'] does not
      belong to a package
    - dependencies: names and versions of depending packages; not present if
      pkg is not present
    - procstatus: /proc/<pid>/status
    - lsb_release: lsb_release -sir
    - uname: uname -a
    '''

    def __init__(self, pid, signum):
	'Collects all information and stores them in the appropriate fields.'

	self.info = {}
	self.info['signal'] = signum
	self.pid = pid

	# determine program name
	self.info['executable'] = os.readlink('/proc/' + pid + '/exe')

	self._get_proc()
	self._get_pkg()
	self._get_os()
	self._get_gdb()

    def _get_proc(self):
	'''Collect information from /proc.'''

	self.info['environment'] = _read_file('/proc/'+ self.pid + '/environ'). \
	    replace('\n', '\\n').replace('\0', '\n').strip()
	self.info['procstatus'] = _read_file('/proc/' + self.pid + '/status')

    def _get_pkg(self):
	'''Check whether executable belongs to a package and determine its
	name, version, and the versions of its dependencies.'''

	# get dpkg -s <package> output
	out = _command_output(['dpkg', '-S', self.info['executable']])
	if out.startswith('Error:'):
	    return 
	pkg = out.split(':', 1)[0]
	pkgstatus = _command_output(['dpkg', '-s', pkg])
	if pkgstatus.startswith('Error:'):
	    return 

	for l in pkgstatus.splitlines():
	    if l.startswith('Version:'):
		self.info['pkg'] = '%s %s' % (pkg, l.split(None, 1)[1])
		break

    def _get_os(self):
	'''Collect information about system.'''

	self.info['lsb_release'] = _command_output(['lsb_release', '-sir']).strip().replace('\n', ' ')
	self.info['uname'] = _command_output(['uname', '-a']).strip()

    def _get_gdb(self):
	'''Get information from gdb.'''

	self.info['stacktrace'] = _command_output(['gdb', '--batch', '--ex',
	    'bt full', self.info['executable'], self.pid], 
	    stderr=open('/dev/null')).replace('\n\n', '\n.\n').strip()
	self.info['thread_stacktrace'] = _command_output(['gdb', '--batch', '--ex',
	    'thread apply all bt full', self.info['executable'], self.pid], 
	    stderr=open('/dev/null')).replace('\n\n', '\n.\n').strip()

#################################################################
#
# main
#
#################################################################

init_error_log()

if len(sys.argv) != 3:
    print >> sys.stderr, 'Usage:', sys.argv[0], '<pid> <signal number>'
    sys.exit(-1)

error_log('called with: ' + str(sys.argv))

(pid, signum) = sys.argv[1:]

# Create crash report file descriptor. We prefer to create the report in
# /var/crash/ if we can create a file there; if not, we just use stderr.

try:
    pidstat = os.stat('/proc/' + pid)
except OSError:
    error_log('Invalid PID')
    sys.exit(1)

try:
    exename = os.readlink('/proc/' + pid + '/exe').replace('/', '_')
    report = '/var/crash/%s.%i.crash' % (exename, pidstat.st_uid)
    if os.path.exists(report):
	error_log('crash-reporter: report %s already exists, doing nothing to avoid disk usage DoS' % report)
	sys.exit(1)
    reportfile = open(report, 'w')
    os.chmod(report, 0600)
    os.chown(report, pidstat.st_uid, 0)
except (OSError, IOError):
    reportfile = sys.stderr

try:
    drop_privileges(pid)
    ic = InformationCollector(pid, signum)
    write_debcontrol(reportfile, ic.info)
except SystemExit:
    raise
except Exception, e:
    error_log('Unhandled exception:')
    traceback.print_exc()
    print >> sys.stderr, 'pid: %i, uid: %i, gid: %i, euid: %i, egid: %i' % (
       os.getpid(), os.getuid(), os.getgid(), os.geteuid(), os.getegid())
